# =============================================================================
# Lesson 1: Docker Fundamentals (7 cards)
# =============================================================================

- title: "What Is a Container?"
  difficulty: "easy"
  tags: ["docker", "containers", "fundamentals"]
  lesson: docker-fundamentals
  Front: |
    What is a Docker container?
  Back: |
    An isolated process (or group of processes) running on the host OS. It has its own filesystem, network interfaces, and process tree, but shares the host's kernel. Not a VM -- just a process with isolation enforced by the kernel.

- title: "Container vs VM"
  difficulty: "easy"
  tags: ["docker", "containers", "virtual machines"]
  lesson: docker-fundamentals
  Front: |
    How does a container differ from a virtual machine?
  Back: |
    A VM runs a full guest OS with its own kernel on a hypervisor. A container shares the host kernel and isolates via namespaces/cgroups.

    | | Container | VM |
    |---|---|---|
    | Startup | Milliseconds | Seconds to minutes |
    | Size | Tens of MB | Gigabytes |
    | Isolation | Process-level | Hardware-level |
    | Density | Hundreds per host | Dozens per host |

- title: "Namespaces vs Cgroups"
  difficulty: "medium"
  tags: ["docker", "containers", "namespaces", "cgroups"]
  lesson: docker-fundamentals
  Front: |
    What do Linux **namespaces** and **cgroups** each control in container isolation?
  Back: |
    **Namespaces** control what a container can *see* -- isolated views of PIDs, network interfaces, mount points, and hostnames.

    **Cgroups** control what a container can *use* -- limits on CPU, memory, disk I/O, and network bandwidth.

- title: "What Is a Docker Image?"
  difficulty: "easy"
  tags: ["docker", "images", "fundamentals"]
  lesson: docker-fundamentals
  Front: |
    What is a Docker image?
  Back: |
    A read-only template containing everything needed to run an application: code, runtime, libraries, and config. It is a stack of filesystem layers plus metadata about how to start the process.

- title: "Image vs Container Relationship"
  difficulty: "easy"
  tags: ["docker", "images", "containers"]
  lesson: docker-fundamentals
  Front: |
    What is the relationship between a Docker image and a container?
  Back: |
    A container is a running instance of an image. Many containers can run from the same image, each with its own writable layer on top. Like running multiple processes from the same binary.

- title: "What Is a Dockerfile?"
  difficulty: "easy"
  tags: ["docker", "Dockerfile", "fundamentals"]
  lesson: docker-fundamentals
  Front: |
    What is a Dockerfile?
  Back: |
    A text file with instructions for building an image. Docker reads it top to bottom, executing each instruction (`FROM`, `RUN`, `COPY`, etc.) to produce the image layer by layer.

- title: "What Is a Registry?"
  difficulty: "easy"
  tags: ["docker", "registry", "Docker Hub"]
  lesson: docker-fundamentals
  Front: |
    What is a container registry, and what is Docker Hub?
  Back: |
    A registry is a server that stores and distributes Docker images. `docker push` uploads an image; `docker pull` downloads one.

    Docker Hub is the default public registry. Most official images (nginx, postgres, python) live there. Organizations use private registries (AWS ECR, GitHub Container Registry) for their own images.

# =============================================================================
# Lesson 2: Essential Docker Commands (9 cards)
# =============================================================================

- title: "CMD vs ENTRYPOINT"
  difficulty: "medium"
  tags: ["docker", "Dockerfile", "CMD", "ENTRYPOINT"]
  lesson: docker-essential-commands
  Front: |
    What is the difference between `CMD` and `ENTRYPOINT` in a Dockerfile?
  Back: |
    **CMD** sets the default command. Fully replaced if you pass args to `docker run`:
    ```
    CMD ["python", "app.py"]
    docker run myimage bash  ->  bash (CMD replaced)
    ```

    **ENTRYPOINT** sets the executable that always runs. Args are appended:
    ```
    ENTRYPOINT ["python", "app.py"]
    docker run myimage --debug  ->  python app.py --debug
    ```

    Together: ENTRYPOINT is the executable, CMD provides default arguments the user can override.

- title: "CMD + ENTRYPOINT Together"
  difficulty: "medium"
  tags: ["docker", "Dockerfile", "CMD", "ENTRYPOINT"]
  lesson: docker-essential-commands
  Front: |
    What happens when a Dockerfile has both `ENTRYPOINT ["python"]` and `CMD ["app.py"]`?
  Back: |
    ENTRYPOINT defines the executable, CMD provides default arguments. `docker run myimage` runs `python app.py`. `docker run myimage test.py` runs `python test.py` (CMD is replaced, ENTRYPOINT stays).

- title: "Exec Form vs Shell Form"
  difficulty: "hard"
  tags: ["docker", "Dockerfile", "exec form", "shell form", "signals"]
  lesson: docker-essential-commands
  Front: |
    Why should you use exec form (`["executable", "arg"]`) instead of shell form (`executable arg`) for CMD and ENTRYPOINT?
  Back: |
    Shell form wraps the command in `/bin/sh -c`, making the shell PID 1 instead of your process. Signals like SIGTERM go to the shell, not your app, so the container cannot shut down gracefully.

    Exec form runs the process directly as PID 1, where it receives signals correctly.

- title: "COPY vs ADD"
  difficulty: "easy"
  tags: ["docker", "Dockerfile", "COPY", "ADD"]
  lesson: docker-essential-commands
  Front: |
    What is the difference between `COPY` and `ADD` in a Dockerfile?
  Back: |
    `COPY` copies files from the build context into the image. Nothing else.

    `ADD` does the same, plus: auto-extracts local `.tar` archives, and can fetch remote URLs (discouraged).

    Prefer `COPY` always. `ADD` has implicit behavior that makes Dockerfiles harder to reason about.

- title: "docker exec"
  difficulty: "easy"
  tags: ["docker", "commands", "exec", "debugging"]
  lesson: docker-essential-commands
  Front: |
    How do you run a command inside a running container?
  Back: |
    `docker exec -it <container> bash`

    `-i` keeps stdin open, `-t` allocates a terminal. This is how you "shell into" a container for debugging. The container must already be running.

- title: "docker stop vs docker kill"
  difficulty: "easy"
  tags: ["docker", "commands", "stop", "kill", "signals"]
  lesson: docker-essential-commands
  Front: |
    What is the difference between `docker stop` and `docker kill`?
  Back: |
    `docker stop` sends SIGTERM first, waits up to 10 seconds for graceful shutdown, then sends SIGKILL.

    `docker kill` sends SIGKILL immediately. No grace period.

    Default to `stop`. Use `kill` only when a container is unresponsive.

- title: "Key docker run Flags"
  difficulty: "medium"
  tags: ["docker", "commands", "run"]
  lesson: docker-essential-commands
  Front: |
    What do the `-d`, `-p`, `--rm`, and `-e` flags do on `docker run`?
  Back: |
    - **`-d`**: Run detached (background)
    - **`-p 8080:80`**: Map host port 8080 to container port 80
    - **`--rm`**: Auto-remove the container when it exits
    - **`-e KEY=VALUE`**: Set an environment variable inside the container

- title: "Container Lifecycle States"
  difficulty: "medium"
  tags: ["docker", "containers", "lifecycle"]
  lesson: docker-essential-commands
  Front: |
    What are the lifecycle states of a Docker container?
  Back: |
    **Created** -- filesystem set up, process not started.
    **Running** -- main process (PID 1) is executing.
    **Paused** -- process frozen via SIGSTOP; resumes where it left off.
    **Stopped** -- process exited. Container and writable layer still on disk.
    **Removed** -- container and writable layer deleted.

    `docker stop` = Running to Stopped. `docker rm` = Stopped to Removed.

- title: "docker logs"
  difficulty: "easy"
  tags: ["docker", "commands", "logs", "debugging"]
  lesson: docker-essential-commands
  Front: |
    How do you view a container's stdout/stderr output?
  Back: |
    `docker logs <container>` shows the output. Add `-f` to follow in real time (like `tail -f`). Works on both running and stopped containers.

# =============================================================================
# Lesson 3: Storage and Volumes (6 cards)
# =============================================================================

- title: "Ephemeral Container Filesystem"
  difficulty: "easy"
  tags: ["docker", "storage", "ephemeral", "writable layer"]
  lesson: docker-storage-and-volumes
  Front: |
    What happens to files written inside a container when the container is removed?
  Back: |
    They are gone. All writes go to the container's writable layer, which is deleted on `docker rm`.

    `docker stop` preserves the writable layer (container still on disk). `docker rm` destroys it. Anything that must survive container replacement must be stored outside the writable layer.

- title: "What Is a Docker Volume?"
  difficulty: "easy"
  tags: ["docker", "volumes", "storage"]
  lesson: docker-storage-and-volumes
  Front: |
    What is a Docker volume?
  Back: |
    A directory managed by Docker, stored at `/var/lib/docker/volumes/` on the host. Volumes persist independently of any container -- they survive container removal until explicitly deleted. Portable across hosts and can be shared between containers.

- title: "What Is a Bind Mount?"
  difficulty: "easy"
  tags: ["docker", "bind mounts", "storage"]
  lesson: docker-storage-and-volumes
  Front: |
    What is a Docker bind mount?
  Back: |
    A direct mapping of a host directory into the container (`-v /host/path:/container/path`). Both sides see the same files in real time. Depends on the host's directory structure, so not portable.

- title: "Volume vs Bind Mount"
  difficulty: "medium"
  tags: ["docker", "volumes", "bind mounts", "storage"]
  lesson: docker-storage-and-volumes
  Front: |
    When should you use a Docker volume vs a bind mount?
  Back: |
    **Volumes** for production data (databases, application state). Docker-managed, portable, survive container replacement.

    **Bind mounts** for development. Mount source code so host edits trigger live reload inside the container. Not portable -- tied to host paths.

- title: "tmpfs Mounts"
  difficulty: "medium"
  tags: ["docker", "tmpfs", "storage"]
  lesson: docker-storage-and-volumes
  Front: |
    What is a tmpfs mount and when would you use one?
  Back: |
    A mount stored entirely in host RAM. Data disappears when the container stops (not just when removed). Never written to disk.

    Use for ephemeral secrets or session tokens that should not touch the filesystem, or scratch space for temporary computation.

- title: "Docker Storage Options List"
  difficulty: "easy"
  tags: ["docker", "storage", "volumes", "bind mounts", "tmpfs"]
  lesson: docker-storage-and-volumes
  Front: |
    What are Docker's three storage options for persisting data beyond the container's writable layer?
  Back: |
    1. **Volumes** -- Docker-managed, stored in `/var/lib/docker/volumes/`
    2. **Bind mounts** -- maps a host directory into the container
    3. **tmpfs mounts** -- stored in RAM only, gone when the container stops

# =============================================================================
# Lesson 4: Networking (7 cards)
# =============================================================================

- title: "Docker Networking Modes List"
  difficulty: "easy"
  tags: ["docker", "networking"]
  lesson: docker-networking
  Front: |
    What are Docker's three main networking modes?
  Back: |
    **Bridge** (default), **Host**, and **None**.

- title: "Bridge Network"
  difficulty: "easy"
  tags: ["docker", "networking", "bridge"]
  lesson: docker-networking
  Front: |
    How does Docker's bridge networking mode work?
  Back: |
    Containers get their own IP on a private virtual network, isolated from the host. To expose a port, use `-p 8080:80` (host port:container port). This is the default mode.

- title: "User-Defined Bridge vs Default Bridge"
  difficulty: "medium"
  tags: ["docker", "networking", "bridge", "DNS"]
  lesson: docker-networking
  Front: |
    What does a user-defined bridge network provide that the default bridge does not?
  Back: |
    Automatic DNS resolution by container name. Docker runs an embedded DNS server (at 127.0.0.11) on user-defined bridges. On the default bridge, containers can only communicate by IP address.

    Always use a user-defined bridge for multi-container apps so services can find each other by name.

- title: "Host Network Mode"
  difficulty: "easy"
  tags: ["docker", "networking", "host"]
  lesson: docker-networking
  Front: |
    What does Docker's host networking mode do?
  Back: |
    Removes all network isolation. The container shares the host's network stack directly -- same IP, same ports. No `-p` flag needed.

    Trade-off: maximum network performance (no NAT overhead), but no port isolation and no network security boundary.

- title: "None Network Mode"
  difficulty: "easy"
  tags: ["docker", "networking", "none"]
  lesson: docker-networking
  Front: |
    What does Docker's none networking mode do?
  Back: |
    Disables all networking. The container has only a loopback interface (127.0.0.1). Cannot reach the network and nothing can reach it. Use for security-sensitive workloads that must have zero network access.

- title: "Port Mapping"
  difficulty: "medium"
  tags: ["docker", "networking", "port mapping"]
  lesson: docker-networking
  Front: |
    What does `-p 8080:80` do on `docker run`, and what happens if you omit `-p`?
  Back: |
    Maps host port 8080 to container port 80. Traffic hitting `localhost:8080` on the host is forwarded to port 80 inside the container.

    Without `-p`, the container's ports are not accessible from the host, even if a process is listening inside. The port exists only on the container's virtual network.

- title: "EXPOSE Does Not Publish"
  difficulty: "medium"
  tags: ["docker", "networking", "Dockerfile", "EXPOSE"]
  lesson: docker-networking
  Front: |
    Does `EXPOSE 80` in a Dockerfile publish port 80 when the container runs?
  Back: |
    No. `EXPOSE` is documentation only -- metadata for humans and tooling. It does not open or map any ports at runtime. You still need `-p 80:80` on `docker run` to make the port accessible from the host.

# =============================================================================
# Lesson 5: Layers and Build Cache (10 cards)
# =============================================================================

- title: "Layer-Creating Instructions"
  difficulty: "easy"
  tags: ["docker", "layers", "Dockerfile"]
  lesson: docker-layers-build-cache
  Front: |
    Which Dockerfile instructions create filesystem layers?
  Back: |
    `RUN`, `COPY`, and `ADD`. Each creates an immutable layer recording only the filesystem diff.

    Instructions like `ENV`, `WORKDIR`, `EXPOSE`, `CMD`, and `ENTRYPOINT` add metadata but do not produce layers.

- title: "Cache Invalidation Cascade"
  difficulty: "medium"
  tags: ["docker", "build cache", "Dockerfile"]
  lesson: docker-layers-build-cache
  Front: |
    What is the most important rule about Docker build cache invalidation?
  Back: |
    It cascades downward. Once one layer's cache is invalidated, every subsequent layer must rebuild, even if those instructions haven't changed. Docker evaluates top to bottom and stops reusing cache at the first miss.

- title: "COPY/ADD Cache Check"
  difficulty: "medium"
  tags: ["docker", "build cache", "COPY"]
  lesson: docker-layers-build-cache
  Front: |
    How does Docker decide whether a `COPY` instruction can use the cache?
  Back: |
    Docker computes checksums of the source files' content. If any file's content changed, the layer is invalidated. Timestamps are ignored -- only content matters.

- title: "RUN Cache Check"
  difficulty: "medium"
  tags: ["docker", "build cache", "RUN"]
  lesson: docker-layers-build-cache
  Front: |
    How does Docker decide whether a `RUN` instruction can use the cache?
  Back: |
    Docker only compares the command string. If the string is identical and the parent layer is cached, the layer is reused. Docker does not inspect what the command does.

    This means `RUN apt-get update` can return stale results -- the command string hasn't changed, so Docker treats it as a cache hit.

- title: "Instruction Ordering for Cache"
  difficulty: "medium"
  tags: ["docker", "build cache", "Dockerfile", "optimization"]
  lesson: docker-layers-build-cache
  Front: |
    Why should you copy the dependency manifest and install dependencies *before* copying source code in a Dockerfile?
  Back: |
    Because cache invalidation cascades. If `COPY . .` comes first, any source change invalidates that layer and forces dependency installation to re-run.

    Copy `requirements.txt` (or `package.json`, `go.mod`) first, run install, then copy source. Dependencies are cached as long as the manifest is unchanged.

- title: ".dockerignore Purpose"
  difficulty: "easy"
  tags: ["docker", "dockerignore", "build cache"]
  lesson: docker-layers-build-cache
  Front: |
    What does `.dockerignore` do and why does it matter for build speed?
  Back: |
    Excludes files from the build context before it is sent to the daemon. Excluded files cannot trigger cache invalidation on `COPY . .`.

    Without it, changes to `.git/`, `node_modules/`, or `__pycache__/` bust the cache on every build even though they are irrelevant to the image.

- title: "What Is a Multi-Stage Build?"
  difficulty: "easy"
  tags: ["docker", "multi-stage", "Dockerfile"]
  lesson: docker-layers-build-cache
  Front: |
    What is a multi-stage Docker build?
  Back: |
    A Dockerfile with multiple `FROM` statements. Each begins a new stage with a clean filesystem. Build in an early stage, then `COPY --from=<stage>` only the output into a minimal final stage. Only the last stage becomes the image.

- title: "Multi-Stage Build Benefits"
  difficulty: "medium"
  tags: ["docker", "multi-stage", "image size", "security"]
  lesson: docker-layers-build-cache
  Front: |
    Why do multi-stage builds produce smaller and more secure images?
  Back: |
    The final image contains only the runtime artifact and its base. Compilers, SDKs, source code, and build tools are left in earlier stages and discarded.

    A Go binary in Alpine can be ~20 MB vs 800+ MB with the full Go SDK. Fewer tools also means a smaller attack surface if the container is compromised.

- title: "Copy-on-Write"
  difficulty: "medium"
  tags: ["docker", "layers", "copy-on-write"]
  lesson: docker-layers-build-cache
  Front: |
    What happens when a running container modifies a file from an image layer?
  Back: |
    Copy-on-write: Docker copies the file into the container's writable layer before applying the change. The original image layer is never modified. Reads fall through to the lowest layer containing the file; writes go to the top.

- title: "Deleting Files Across Layers"
  difficulty: "hard"
  tags: ["docker", "layers", "image size"]
  lesson: docker-layers-build-cache
  Front: |
    You `COPY` a 500 MB file in one Dockerfile instruction and `RUN rm` it in the next. Does the image shrink?
  Back: |
    No. The file persists in the earlier layer. The later layer adds a whiteout marker that hides it at runtime, but the bytes remain in the image.

    Fix: remove the file in the same `RUN` that created it, never add it in the first place, or use a multi-stage build where the file never enters the final stage.

# =============================================================================
# Lesson 6: Docker Compose (8 cards)
# =============================================================================

- title: "What Is Docker Compose?"
  difficulty: "easy"
  tags: ["docker", "docker compose"]
  lesson: docker-compose
  Front: |
    What is Docker Compose?
  Back: |
    A tool for defining and running multi-container applications. You describe services, networks, and volumes in a YAML file. `docker compose up` creates and starts everything; `docker compose down` tears it down.

- title: "Compose File Top-Level Keys"
  difficulty: "easy"
  tags: ["docker", "docker compose", "YAML"]
  lesson: docker-compose
  Front: |
    What are the three top-level keys in a `docker-compose.yml` file?
  Back: |
    `services`, `networks`, and `volumes`.

    **services** -- container definitions (image, ports, env vars, etc.)
    **networks** -- custom networks for inter-service communication
    **volumes** -- named volumes for persistent data

- title: "Compose Automatic Networking"
  difficulty: "medium"
  tags: ["docker", "docker compose", "networking", "DNS"]
  lesson: docker-compose
  Front: |
    How do services in a Docker Compose project communicate with each other?
  Back: |
    Compose automatically creates a user-defined bridge network. All services are attached to it and can reach each other by service name via Docker's embedded DNS. No manual network creation or IP addresses needed.

- title: "depends_on Behavior"
  difficulty: "hard"
  tags: ["docker", "docker compose", "depends_on"]
  lesson: docker-compose
  Front: |
    What does `depends_on` control in Docker Compose, and what does it NOT do?
  Back: |
    It controls **startup order** -- the dependency starts first. It does NOT wait for the dependency to be *ready*. `depends_on: [db]` starts the db container before the app, but does not wait for Postgres to accept connections.

    For readiness, add `condition: service_healthy` with a healthcheck on the dependency.

- title: "Compose down and Volumes"
  difficulty: "medium"
  tags: ["docker", "docker compose", "volumes"]
  lesson: docker-compose
  Front: |
    What does `docker compose down` remove, and how do you also delete volumes?
  Back: |
    `docker compose down` stops and removes containers and networks. Named volumes are preserved.

    `docker compose down -v` also deletes named volumes. Data is gone.

- title: "Compose vs Kubernetes"
  difficulty: "medium"
  tags: ["docker", "docker compose", "kubernetes", "orchestration"]
  lesson: docker-compose
  Front: |
    When is Docker Compose sufficient vs when do you need Kubernetes?
  Back: |
    **Compose** is single-host orchestration. No multi-node scaling, no automatic failover. Use for local dev, CI, and small single-server deployments.

    **Kubernetes** is multi-host orchestration with auto-scaling, rolling updates, self-healing, and service discovery across a cluster.

    Dividing line: if the app runs on one machine and doesn't need automatic recovery from node failure, Compose is simpler.

- title: "Essential Compose Commands"
  difficulty: "easy"
  tags: ["docker", "docker compose", "commands"]
  lesson: docker-compose
  Front: |
    What are the most common Docker Compose commands?
  Back: |
    - `docker compose up -d` -- start all services (detached)
    - `docker compose down` -- stop and remove containers + network
    - `docker compose logs -f <service>` -- follow logs for a service
    - `docker compose exec <service> bash` -- shell into a running service
    - `docker compose up --build` -- rebuild images before starting
    - `docker compose ps` -- list running services

- title: "What Is a Compose Service?"
  difficulty: "easy"
  tags: ["docker", "docker compose", "services"]
  lesson: docker-compose
  Front: |
    What is a "service" in Docker Compose?
  Back: |
    A container definition within the `services:` block. Each service specifies an image or build context, plus configuration (ports, env vars, volumes, dependencies). Compose creates a container for each service, named `{project}-{service}-1` by default.
