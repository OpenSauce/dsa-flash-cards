- title: "Kubernetes Core - Pods"
  difficulty: "easy"
  tags: ["kubernetes", "pods", "containers"]
  Front: |
    What is a **Pod** and why is it the smallest deployable unit in Kubernetes (not a container)?
  Back: |
    A Pod is a group of one or more containers that share the same network namespace, IP address, and storage volumes. It is the smallest unit Kubernetes can schedule and manage.

    **Why not just a container?**
    Containers in a Pod share `localhost` -- they can communicate over `127.0.0.1` without any networking configuration. They also share mounted volumes. This makes Pods the natural unit for tightly coupled processes that must run together.

    **The sidecar pattern:**
    A common use of multi-container Pods is the sidecar pattern. The main container runs your application, and a sidecar container handles a cross-cutting concern like logging (Fluentd), proxying (Envoy), or secret injection (Vault agent). Both containers share the Pod's network and filesystem.

    **Key insight:** You almost never create Pods directly. You create Deployments or StatefulSets that manage Pods for you. A bare Pod that crashes will not be rescheduled.

    **Interview tip:** Emphasize that a Pod is an abstraction over containers, not a synonym. The shared network namespace is the critical detail.

- title: "Kubernetes Core - Deployments"
  difficulty: "medium"
  tags: ["kubernetes", "deployments", "rolling updates", "ReplicaSet"]
  Front: |
    What is a **Deployment** and how does it manage rolling updates?
  Back: |
    A Deployment declares the desired state for a set of Pods -- which container image to run, how many replicas, and how to update them. Kubernetes continuously reconciles the actual state to match the desired state.

    **How rolling updates work:**
    When you change the Pod template (e.g., update the container image), the Deployment creates a new ReplicaSet and gradually scales it up while scaling the old ReplicaSet down.

    - `maxSurge` controls how many extra Pods can exist during the update (e.g., 25% above desired count)
    - `maxUnavailable` controls how many Pods can be down simultaneously (e.g., 25% of desired count)

    **Rollback:** Every Deployment change creates a new ReplicaSet revision. If the new version is broken, `kubectl rollout undo` switches back to the previous ReplicaSet instantly -- no need to rebuild or redeploy.

    **Why not create ReplicaSets directly?** A Deployment manages ReplicaSets for you. It handles versioning, rollback, and update strategy. Creating a ReplicaSet directly gives you replica management but no update orchestration.

    **Interview tip:** When discussing zero-downtime deployments in Kubernetes, describe the rolling update mechanism and mention `maxSurge`/`maxUnavailable` as the controls.

- title: "Kubernetes Core - ReplicaSets"
  difficulty: "easy"
  tags: ["kubernetes", "ReplicaSet", "pods", "scaling"]
  Front: |
    What is a **ReplicaSet** and how does it differ from a Deployment?
  Back: |
    A ReplicaSet ensures that a specified number of identical Pod replicas are running at all times. If a Pod crashes or is deleted, the ReplicaSet creates a replacement.

    **How it works:** The ReplicaSet uses label selectors to identify which Pods it owns. It continuously compares the actual count of matching Pods against the desired count and creates or deletes Pods to reconcile.

    **How it differs from a Deployment:**
    - A **ReplicaSet** manages Pod count -- it ensures N replicas exist
    - A **Deployment** manages ReplicaSets -- it handles updates, rollbacks, and versioning

    When a Deployment performs a rolling update, it creates a new ReplicaSet (with the updated Pod template) and scales down the old one. The old ReplicaSet is kept with zero replicas so rollback is instant.

    **In practice:** You almost never create a ReplicaSet directly. You create a Deployment, which creates and manages ReplicaSets for you. The only reason to know about ReplicaSets is to understand what Deployments are doing under the hood.

    **Interview tip:** If asked about ReplicaSets, explain the Deployment-to-ReplicaSet relationship. It demonstrates you understand the resource hierarchy.

- title: "Kubernetes Core - Services"
  difficulty: "medium"
  tags: ["kubernetes", "services", "networking", "ClusterIP", "NodePort", "LoadBalancer"]
  Front: |
    What is a **Service** and what are the three main types (ClusterIP, NodePort, LoadBalancer)?
  Back: |
    A Service provides a stable network endpoint for a set of Pods. Pods are ephemeral -- they get new IP addresses when recreated. A Service gives them a permanent DNS name and IP address that other services can rely on.

    **How it works:** A Service uses label selectors to find its target Pods and load-balances traffic across them. When Pods are added or removed, the Service updates its endpoint list automatically.

    **Three types:**
    - **ClusterIP (default):** Accessible only within the cluster. Gets an internal IP address. Used for service-to-service communication (e.g., backend talking to a database).
    - **NodePort:** Exposes the Service on a static port on every node's IP. Accessible from outside the cluster via `<NodeIP>:<NodePort>`. Useful for development, but not ideal for production because it bypasses load balancing across nodes.
    - **LoadBalancer:** Provisions an external cloud load balancer (e.g., AWS ELB, GCP LB) that routes traffic to the Service. The standard way to expose a service to the internet in a cloud environment.

    **Decision framework:** ClusterIP for internal services, LoadBalancer for external traffic, NodePort for quick testing or on-prem environments without cloud load balancers.

    **Interview tip:** Mention that Services decouple consumers from Pods. A consumer talks to the Service DNS name, not to specific Pod IPs.

- title: "Kubernetes Core - Namespaces"
  difficulty: "easy"
  tags: ["kubernetes", "namespaces", "isolation"]
  Front: |
    What is a **Namespace** and when would you use one?
  Back: |
    A Namespace is a virtual partition within a Kubernetes cluster. It provides logical isolation for resources -- Pods, Services, and ConfigMaps in one Namespace are separate from those in another.

    **Default Namespaces:**
    - `default` -- where resources go if you do not specify a Namespace
    - `kube-system` -- Kubernetes system components (API server, CoreDNS, kube-proxy)
    - `kube-public` -- readable by all users, typically used for cluster-wide configuration

    **When to use Namespaces:**
    - **Multi-team clusters:** Each team gets a Namespace with resource quotas and RBAC policies
    - **Environment separation:** Run `staging` and `production` Namespaces in the same cluster (though separate clusters are safer for true isolation)
    - **Resource quotas:** Limit CPU, memory, and object counts per Namespace to prevent one team from starving others

    **What Namespaces do NOT provide:**
    - Network isolation (by default, Pods in different Namespaces can communicate freely -- you need NetworkPolicies for that)
    - Strong security boundaries (a cluster-admin can access all Namespaces)

    **Interview tip:** Namespaces are organizational, not security boundaries. If asked about multi-tenancy, mention that Namespaces plus NetworkPolicies plus RBAC together provide isolation -- Namespaces alone are not enough.

- title: "Kubernetes Core - StatefulSets"
  difficulty: "medium"
  tags: ["kubernetes", "StatefulSet", "stateful", "databases"]
  Front: |
    What is a **StatefulSet** and when would you use it instead of a Deployment?
  Back: |
    A StatefulSet manages Pods that need stable identities and persistent storage. Unlike a Deployment, where Pods are interchangeable, StatefulSet Pods are unique and ordered.

    **What a StatefulSet provides:**
    - **Stable network identity:** Each Pod gets a predictable hostname (`pod-0`, `pod-1`, `pod-2`) that persists across restarts. A Deployment assigns random names.
    - **Ordered deployment and scaling:** Pods are created sequentially (0, then 1, then 2) and terminated in reverse order. This matters for databases that require leader election or sequential initialization.
    - **Persistent storage:** Each Pod gets its own PersistentVolumeClaim. When `pod-1` is rescheduled, it reattaches to the same volume with the same data.

    **When to use a StatefulSet:**
    - Databases (PostgreSQL, MySQL) where each instance has its own data
    - Distributed systems that require stable peer identities (Kafka brokers, Zookeeper nodes, etcd members)
    - Any workload where Pods are not interchangeable

    **When to use a Deployment instead:** Stateless applications where any Pod can handle any request -- web servers, API servers, workers. Most workloads are stateless and belong in a Deployment.

    **Interview tip:** The key distinction is identity. Deployment Pods are cattle (replaceable), StatefulSet Pods are pets (unique). Use StatefulSets only when the workload genuinely requires it.
