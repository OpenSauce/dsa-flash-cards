title: "Configuration and Secrets"
lesson_slug: "k8s-configuration-and-secrets"
questions:
  - question: "What is the intended difference between a ConfigMap and a Secret?"
    options:
      - "ConfigMaps are cluster-scoped; Secrets are Namespace-scoped"
      - "ConfigMaps are for non-sensitive key-value config; Secrets are for sensitive data like passwords and API keys"
      - "ConfigMaps can only be consumed as environment variables; Secrets can only be consumed as volume mounts"
      - "ConfigMaps are deleted when the Pod is deleted; Secrets persist independently"
    correct: 1
    explanation: "ConfigMaps store non-sensitive configuration (database hostnames, feature flags, log levels) as plaintext. Secrets are designed for sensitive data (passwords, TLS certificates, API keys). Both are Namespace-scoped. Both support environment variable and volume mount consumption."

  - question: "Why are Kubernetes Secrets NOT encrypted by default?"
    options:
      - "Encryption would add too much latency to etcd reads"
      - "Secrets are stored as base64-encoded values in etcd -- base64 is encoding, not encryption, and is trivially reversible"
      - "Kubernetes delegates encryption to the container runtime"
      - "Secrets are only stored in memory, never written to disk"
    correct: 1
    explanation: "Base64 is a way to represent binary data as ASCII text -- it is not cryptographic. Anyone with RBAC access to the Secret or direct etcd access can decode it instantly with `base64 -d`. Production security requires enabling etcd encryption at rest and/or using an external secret manager (Vault, AWS Secrets Manager)."

  - question: "What is the advantage of consuming a ConfigMap as a volume mount instead of environment variables?"
    options:
      - "Volume-mounted ConfigMaps can be larger than 1MB; env var ConfigMaps cannot"
      - "Volume-mounted ConfigMaps update automatically when the ConfigMap changes; environment variables require a container restart"
      - "Volume-mounted ConfigMaps are encrypted; env var ConfigMaps are not"
      - "Volume-mounted ConfigMaps can be shared between Namespaces"
    correct: 1
    explanation: "When a ConfigMap is updated and mounted as a volume, Kubernetes propagates the updated file content to the running container automatically (with a short propagation delay). Environment variables are injected once at container start and do not change until the container restarts. For configuration hot-reload, volume mounts are the right approach."

  - question: "What happens when a container exceeds its memory limit?"
    options:
      - "The container is throttled until memory usage drops below the limit"
      - "Kubernetes evicts the Pod from the node and reschedules it elsewhere"
      - "The container is OOMKilled by the kernel and restarted according to the Pod's restartPolicy"
      - "The container's memory limit is automatically increased by 25%"
    correct: 2
    explanation: "When a container exceeds its memory limit, the Linux kernel sends an OOMKill signal. The container dies immediately -- no graceful shutdown, no cleanup. Kubernetes then restarts it according to restartPolicy. Repeated OOMKills cause the container to enter CrashLoopBackOff with exponential backoff delays."

  - question: "What happens when a container exceeds its CPU limit?"
    options:
      - "The container is OOMKilled immediately"
      - "The Pod is evicted and rescheduled to a node with more CPU"
      - "The container is throttled -- it runs slower but is not killed"
      - "The CPU limit is ignored and the container continues at full speed"
    correct: 2
    explanation: "CPU limits are enforced via Linux cgroup CPU quota. When a container exceeds its limit, the kernel reduces its scheduled CPU time -- the container runs slower, not faster. Unlike memory, unused CPU time can always be redistributed among other processes, so there is no need to kill the container."

  - question: "What is the trade-off of setting resource requests equal to limits (Guaranteed QoS class)?"
    options:
      - "The Pod gets higher scheduling priority but slower network access"
      - "The Pod cannot use ConfigMaps or Secrets"
      - "Resources are reserved exclusively for the container (predictable performance), but the cluster cannot overcommit, reducing utilization"
      - "The Pod is never evicted but cannot be rescheduled after a node failure"
    correct: 2
    explanation: "When requests equal limits, Kubernetes assigns the Pod Guaranteed QoS. The node reserves exactly that much capacity. The benefit: the container always gets what it requested -- no surprises under load. The cost: that capacity is blocked even when idle, reducing cluster packing efficiency compared to Burstable QoS (requests < limits)."
