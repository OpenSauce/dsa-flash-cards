- title: "Kubernetes Architecture - Control Plane"
  difficulty: "hard"
  tags:
    [
      "kubernetes",
      "control plane",
      "API server",
      "etcd",
      "scheduler",
      "controller manager",
    ]
  Front: |
    What are the components of the **Kubernetes control plane** and what does each do?
  Back: |
    The control plane is the brain of the cluster. It makes all scheduling and reconciliation decisions. In production, it runs on dedicated nodes (typically 3 or 5 for high availability).

    **API Server (kube-apiserver):** The front door to the cluster. Every interaction -- `kubectl` commands, kubelet heartbeats, controller reconciliation -- goes through the API server. It validates and processes RESTful requests, authenticates users, and persists state to etcd. It is the only component that talks to etcd directly.

    **etcd:** A distributed key-value store that holds all cluster state -- every Pod, Service, ConfigMap, and Secret definition. It uses the Raft consensus algorithm for consistency. If etcd is lost and unrecoverable, the cluster state is gone. This is why etcd backups are critical.

    **Scheduler (kube-scheduler):** Watches for newly created Pods with no assigned node and picks the best node for each one. The decision considers resource requests, affinity/anti-affinity rules, taints and tolerations, and topology constraints.

    **Controller Manager (kube-controller-manager):** Runs reconciliation loops that continuously compare desired state (what you declared) with actual state (what exists). Includes the ReplicaSet controller, Deployment controller, Node controller, and Job controller. Each loop detects drift and takes corrective action.

    **Cloud Controller Manager:** Handles cloud-specific operations -- provisioning load balancers for LoadBalancer Services, managing cloud routes, and attaching cloud storage. Only present in cloud-hosted clusters.

    **Interview tip:** Frame the control plane as a reconciliation system. You declare the desired state, and the controllers continuously drive the actual state toward it. This declarative model is the core of Kubernetes.

- title: "Kubernetes Architecture - Worker Nodes"
  difficulty: "hard"
  tags:
    ["kubernetes", "kubelet", "kube-proxy", "container runtime", "worker node"]
  Front: |
    What are the roles of **kubelet** and **kube-proxy** on a worker node?
  Back: |
    Worker nodes are where application Pods actually run. Each worker node runs three essential components.

    **Kubelet:** The node agent. It registers the node with the API server, watches for Pod assignments, and ensures the assigned containers are running and healthy.
    - Pulls container images and starts/stops containers via the container runtime
    - Reports node status and resource usage back to the API server (the heartbeat)
    - Executes liveness, readiness, and startup probes
    - If a container crashes, the kubelet restarts it according to the Pod's restart policy
    - Mounts volumes and injects ConfigMaps/Secrets into Pods

    **Kube-proxy:** Handles networking rules on each node. It maintains iptables or IPVS rules that route traffic from Service IPs (virtual IPs) to the actual Pod IPs behind them.
    - When a Pod sends traffic to a Service ClusterIP, kube-proxy's rules redirect it to one of the Service's backend Pods
    - Updates rules in real time as Pods are added or removed from Services
    - Can operate in iptables mode (default, good for most clusters) or IPVS mode (better performance at very large scale)

    **Container runtime:** The software that actually runs containers. Kubernetes communicates with it via the **Container Runtime Interface (CRI)**. Common runtimes:
    - **containerd:** The default in most Kubernetes distributions. Lightweight and purpose-built.
    - **CRI-O:** Minimal runtime designed specifically for Kubernetes. Common in OpenShift.
    - Docker was removed as a runtime in Kubernetes v1.24 (though Docker-built images still work fine).

    **Interview tip:** Mention that kubelet and the container runtime are distinct -- kubelet manages Pod lifecycle and the runtime manages container execution. Also note Docker's removal as a direct runtime and why it does not affect image compatibility.
