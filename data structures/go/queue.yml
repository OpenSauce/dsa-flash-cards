# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Queue – Overview"
  difficulty: "easy"
  tags: ["queue", "identify"]
  Front: |
    Which data structure …

    - Operates on a **first-in, first-out** principle
    - Uses **enqueue** at the rear and **dequeue** at the front
    - Is common in task scheduling, buffering, and BFS
  Back: "Queue"

# ── OPERATION CARDS ─────────────────────────────────────────────────────────
- title: "Queue – Dequeue"
  difficulty: "easy"
  tags: ["queue", "dequeue"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    front := q[0]
    q      = q[1:]
    ```
  Back: |
    Dequeue (O(1))

    Removes the front element. In Go, re-slicing with `q[1:]` is O(1) but leaks memory over time since the backing array head is never freed. For production use, prefer a ring buffer.

- title: "Queue – Search"
  difficulty: "easy"
  tags: ["queue", "search"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    found := false
    target := 3
    for _, v := range q {
        if v == target { found = true; break }
    }
    ```
  Back: |
    Linear search (O(n))

    Queues don't support random access, so finding an element requires scanning from front to back. If fast lookup is needed, maintain a parallel set.
