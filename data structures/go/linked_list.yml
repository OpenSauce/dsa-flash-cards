# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Linked List – Overview"
  difficulty: "easy"
  tags: ["linked list", "identify"]
  Front: |
    Which data structure …

    - Consists of nodes connected by **pointers**
    - Allows **O(1)** insertion or deletion at the head
    - Lacks direct (index) access, so search is **O(n)**
  Back: "Linked List"

# ── OPERATION CARDS ─────────────────────────────────────────────────────────
- title: "Linked List – Insert at Head"
  difficulty: "easy"
  tags: ["linked list", "insert"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    type Node struct {
        Val  int
        Next *Node
    }
    head := &Node{Val: 1}
    head  = &Node{Val: 0, Next: head}
    ```
  Back: |
    Insert at head (O(1))

    Creating a new node and pointing it to the old head is constant time. This is the linked list's main advantage over arrays, which require O(n) shifts for front insertion.

- title: "Linked List – Insert at Tail (Singly)"
  difficulty: "easy"
  tags: ["linked list", "insert"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    tail := head
    for tail.Next != nil {
        tail = tail.Next
    }
    tail.Next = &Node{Val: 5}
    ```
  Back: |
    Insert at tail without tail pointer (O(n))

    Without a stored tail pointer you must walk the entire list. Keeping a tail pointer turns this into O(1) — a common optimisation for queue implementations.

- title: "Linked List – Search by Value"
  difficulty: "easy"
  tags: ["linked list", "search"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    cur := head
    target := 3
    for cur != nil && cur.Val != target {
        cur = cur.Next
    }
    ```
  Back: |
    Linear search (O(n))

    No random access means you must traverse node by node. If frequent lookups are needed, consider augmenting the list with a hash map for O(1) access.

- title: "Linked List – Reverse (Iterative)"
  difficulty: "easy"
  tags: ["linked list", "reverse"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    var prev *Node
    cur := head
    for cur != nil {
        nxt := cur.Next
        cur.Next = prev
        prev = cur
        cur = nxt
    }
    head = prev
    ```
  Back: |
    Reverse singly linked list (O(n))

    Uses three pointers to reverse links in one pass. This is one of the most common interview patterns — the key insight is saving `cur.Next` before overwriting it.
