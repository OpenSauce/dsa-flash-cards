# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Hash Map – Overview"
  difficulty: "easy"
  tags: ["hashmap", "identify"]
  Front: |
    Which data structure …

    - Maps **keys to values** via a **hash function**
    - Aims for **O(1)** average-case insert, delete, and lookup
    - Suffers collisions that can degrade to **O(n)**
  Back: "Hash Map"

# ── OPERATION CARDS ─────────────────────────────────────────────────────────
- title: "Hash Map – Lookup by Key"
  difficulty: "easy"
  tags: ["hashmap", "lookup"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    value, ok := m["apple"]
    _ = value; _ = ok
    ```
  Back: |
    Lookup by key (average O(1), worst O(n))

    The two-value form lets you distinguish "key exists with zero value" from "key missing." Worst case O(n) happens when all keys hash to the same bucket, but Go's map uses randomised hashing to make this unlikely.
