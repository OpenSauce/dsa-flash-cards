# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Hash Map – Overview"
  difficulty: "easy"
  tags: ["hashmap", "identify"]
  Front: |
    Which data structure …

    - Maps **keys to values** via a **hash function**
    - Aims for **O(1)** average-case insert, delete, and lookup
    - Suffers collisions that can degrade to **O(n)**
  Back: |
    **Hash Map**

    A key-value store backed by an array of buckets, where a hash function maps each key to a bucket index for O(1) average-case lookup, insert, and delete. Worst case degrades to O(n) when many keys collide into the same bucket. Collisions are typically resolved via chaining (linked list per bucket) or open addressing (probing for the next empty slot).

# ── OPERATION CARDS ─────────────────────────────────────────────────────────
- title: "Hash Map – Lookup by Key"
  difficulty: "easy"
  tags: ["hashmap", "lookup"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    value, ok := m["apple"]
    _ = value; _ = ok
    ```
  Back: |
    Lookup by key (average O(1), worst O(n))

    The two-value form lets you distinguish "key exists with zero value" from "key missing." Worst case O(n) happens when all keys hash to the same bucket, but Go's map uses randomised hashing to make this unlikely.
