# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Binary Tree – Overview"
  difficulty: "easy"
  tags: ["binary tree", "identify"]
  Front: |
    Which data structure …

    - Is a hierarchical collection where each node has **up to two children**
    - Has **no ordering constraint** between child nodes
    - Forms the foundation for heaps, BSTs, etc.
  Back: |
    **Binary Tree**

    A hierarchical structure where each node has at most two children (left and right), with no inherent ordering constraint. Variants include full (every node has 0 or 2 children), complete (all levels filled except possibly the last, filled left to right), and balanced (subtree heights differ by at most 1). Binary trees are the foundation for BSTs, heaps, tries, and expression trees.

# ── TRAVERSAL CARDS ────────────────────────────────────────────────────────
- title: "Binary Tree – In-order Traversal"
  difficulty: "easy"
  tags: ["binary tree", "traversal"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    func inorder(n *Node) {
        if n == nil { return }
        inorder(n.Left)
        fmt.Print(n.Val)
        inorder(n.Right)
    }
    ```
  Back: |
    In-order traversal (O(n))

    Visits left subtree, then root, then right. On a BST this produces sorted output. Pre-order and post-order differ only in when the root is visited.

- title: "Binary Tree – Pre-order Traversal"
  difficulty: "easy"
  tags: ["binary tree", "traversal"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    func preorder(n *Node) {
        if n == nil { return }
        fmt.Print(n.Val)
        preorder(n.Left)
        preorder(n.Right)
    }
    ```
  Back: |
    Pre-order traversal (O(n) time, O(h) space)

    Visits root first, then left subtree, then right subtree. The first element visited is always the root, making pre-order useful for **serializing/copying a tree** — you can reconstruct it by inserting nodes in pre-order sequence.

    - **Space:** O(h) for the call stack, where h is the tree height (O(log n) balanced, O(n) skewed).
    - **Iterative version:** Use an explicit stack — push right child first, then left, so left is processed first.

- title: "Binary Tree – Post-order Traversal"
  difficulty: "easy"
  tags: ["binary tree", "traversal"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    func postorder(n *Node) {
        if n == nil { return }
        postorder(n.Left)
        postorder(n.Right)
        fmt.Print(n.Val)
    }
    ```
  Back: |
    Post-order traversal (O(n) time, O(h) space)

    Visits left subtree, then right subtree, then root last. Because children are processed before their parent, post-order is used for **tree deletion** (free children before parent) and **expression evaluation** (evaluate operands before applying the operator).

    - **Key difference from pre-order:** In pre-order the root is first; in post-order the root is last. In-order places the root between the subtrees.

- title: "Binary Tree – Level-order Traversal (BFS)"
  difficulty: "medium"
  tags: ["binary tree", "traversal", "bfs"]
  Front: |
    What tree traversal does this implement? What is its time and space complexity?

    ```go
    func levelOrder(root *Node) [][]int {
        if root == nil { return nil }
        var result [][]int
        q := []*Node{root}
        for len(q) > 0 {
            size := len(q)
            level := []int{}
            for i := 0; i < size; i++ {
                node := q[0]; q = q[1:]
                level = append(level, node.Val)
                if node.Left != nil  { q = append(q, node.Left) }
                if node.Right != nil { q = append(q, node.Right) }
            }
            result = append(result, level)
        }
        return result
    }
    ```
  Back: |
    Level-order (BFS) traversal — O(n) time, O(w) space

    Uses a queue to visit nodes level by level, left to right. Capture `size := len(q)` at the start of each loop to process exactly one level per iteration.

    - **Space:** O(w) where w is the maximum width. For a complete tree, the last level holds ~n/2 nodes.
    - **When to use:** Finding minimum depth, level averages, right-side view, or any problem requiring level-by-level processing.
    - **DFS vs BFS for trees:** DFS (in/pre/post-order) uses O(h) space. BFS uses O(w) space. On a balanced tree h = log n and w = n/2, so DFS is more space-efficient. On a skewed tree h = n and w = 1, so BFS wins.

# ── PROPERTY CARDS ─────────────────────────────────────────────────────────
- title: "Binary Tree – Maximum Depth"
  difficulty: "medium"
  tags: ["binary tree", "depth", "recursion"]
  Front: |
    **Binary Tree** — What property does this compute? What is its time and space complexity?

    ```go
    func maxDepth(root *Node) int {
        if root == nil { return 0 }
        left := maxDepth(root.Left)
        right := maxDepth(root.Right)
        if left > right {
            return left + 1
        }
        return right + 1
    }
    ```
  Back: |
    Maximum depth (height) of a binary tree — O(n) time, O(h) space

    The depth of a node is the number of edges from the root to that node. The height of a tree is the maximum depth across all nodes. This recursive solution visits every node exactly once (O(n)) and uses O(h) stack space.

    - **Base case:** An empty tree has depth 0.
    - **Recurrence:** `depth(node) = 1 + max(depth(left), depth(right))`
    - **Balanced vs skewed:** A balanced tree has height O(log n), so recursion depth is manageable. A fully skewed tree has height O(n), which can cause a stack overflow — in that case, use an iterative BFS approach.
    - **Interview variant:** "Minimum depth" is similar but returns the shortest root-to-leaf path. Be careful: a node with only one child is not a leaf, so you cannot just swap `max` for `min`.

- title: "Binary Tree – When to Use Each Traversal"
  difficulty: "medium"
  tags: ["binary tree", "traversal", "concepts"]
  Front: |
    **Binary Tree** — When would you choose in-order, pre-order, post-order, or level-order traversal? Give a concrete use case for each.
  Back: |
    **Choosing a traversal order**

    - **In-order (Left, Root, Right):** Produces sorted output on a BST. Use for sorted iteration, finding the kth smallest element, or validating BST property.
    - **Pre-order (Root, Left, Right):** Visits the root first. Use for tree serialization/cloning — recording nodes in pre-order lets you reconstruct the tree by inserting in that sequence.
    - **Post-order (Left, Right, Root):** Visits children before parent. Use for safe deletion (free children first), computing subtree sizes, and evaluating expression trees (operands before operator).
    - **Level-order (BFS):** Visits level by level. Use when the answer depends on depth — minimum depth, level averages, right-side view, or shortest path in an unweighted tree.

    **Rule of thumb:** If the problem involves "depth" or "level," use BFS. If it involves "subtree" properties, use DFS (usually post-order). If it involves sorted order on a BST, use in-order.
