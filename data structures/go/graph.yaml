# ── GRAPH (ADJACENCY LIST) ─────────────────────────────────────────────────
- title: "Graph (Adjacency List) - Overview"
  difficulty: "easy"
  tags: ["graph", "identify"]
  Front: |
    Which data structure …

    - Represents vertices with **lists of neighbours**
    - Uses **O(V+E)** space
    - Allows **O(1)** expected add-edge?
  Back: "Graph (Adjacency List)"

- title: "Graph – Add Edge (Undirected)"
  difficulty: "easy"
  tags: ["graph", "add edge"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    g[u] = append(g[u], v)
    g[v] = append(g[v], u)
    ```
  Back: |
    Add undirected edge (O(1) average)

    Both endpoints get the other appended to their adjacency list. For directed graphs only one append is needed. Checking for duplicate edges in u's adjacency list requires O(degree(u)) — use a set per vertex if duplicates matter.

- title: "Graph – BFS Traversal"
  difficulty: "easy"
  tags: ["graph", "bfs"]
  Front: |
    What graph traversal algorithm is this? What is its time and space complexity?

    ```go
    q := []int{start}
    vis := map[int]bool{start: true}
    for len(q) > 0 {
        v := q[0]; q = q[1:]
        for _, nb := range g[v] {
            if !vis[nb] {
                vis[nb] = true
                q = append(q, nb)
            }
        }
    }
    ```
  Back: |
    Breadth-First Search (O(V+E))

    Explores nodes level by level using a queue, guaranteeing shortest path in unweighted graphs. Mark nodes visited before enqueuing (not after dequeuing) to avoid processing the same node multiple times.
