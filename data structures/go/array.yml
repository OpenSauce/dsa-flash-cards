# ── OVERVIEW ────────────────────────────────────────────────────────────────
- title: "Array – Overview"
  difficulty: "easy"
  tags: ["array", "identify"]
  Front: |
    Which data structure …

    - Stores elements in a **contiguous block of memory**
    - Provides **constant-time access by index**
    - Requires **O(n)** shifts to insert or delete in the middle
  Back: "Array"

# ── OPERATION CARDS ─────────────────────────────────────────────────────────
- title: "Array – Search by Value"
  difficulty: "easy"
  tags: ["array", "search"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    target := 30
    idx := -1
    for i, v := range []int{10, 20, 30, 40} {
        if v == target {
            idx = i
            break
        }
    }
    ```
  Back: |
    Linear search (O(n))

    Must check every element in the worst case since arrays have no ordering guarantee. Use binary search on sorted arrays to achieve O(log n) instead.

- title: "Array – Insert at End"
  difficulty: "easy"
  tags: ["array", "insert"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    arr := []int{1, 2, 3}
    arr = append(arr, 4)
    ```
  Back: |
    Insert at end / push-back (amortised O(1))

    Go slices double their backing array when capacity is exceeded, so most appends are O(1). Occasional resizing copies all elements, but amortised over many appends the cost stays constant.

- title: "Array – Delete at End"
  difficulty: "easy"
  tags: ["array", "delete"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    arr := []int{1, 2, 3, 4}
    arr  = arr[:len(arr)-1]
    ```
  Back: |
    Delete at end / pop-back (O(1))

    Re-slicing just moves the length pointer without copying or shifting elements. The removed element's memory is not freed until the backing array is garbage-collected.

- title: "Array – Insert at Beginning"
  difficulty: "easy"
  tags: ["array", "insert"]
  Front: |
    What data structure operation does this implement? What is its time complexity?

    ```go
    arr := []int{2, 3, 4}
    arr  = append([]int{1}, arr...)
    ```
  Back: |
    Insert at beginning (O(n))

    Every existing element must be copied into the new backing array. If you need frequent front insertions, consider a deque or linked list instead.
