- title: "Networking Security - TLS Handshake"
  difficulty: "hard"
  tags: ["networking", "TLS", "SSL", "encryption", "handshake"]
  Front: |
    What happens during a **TLS handshake**?
  Back: |
    The TLS handshake establishes an encrypted connection. TLS 1.3 reduced this to a single round trip (down from two in TLS 1.2).

    **TLS 1.3 steps:**
    1. **Client Hello:** Client sends supported cipher suites and a key share (its half of the key exchange).
    2. **Server Hello:** Server picks a cipher suite, sends its key share, its certificate, and a "Finished" message -- all in one response.
    3. **Client Finished:** Client verifies the server's certificate against trusted CAs, computes the shared secret from both key shares, and sends its "Finished" message.

    Both sides now have a symmetric session key derived from the key exchange. All subsequent data is encrypted with this key.

    **Why it matters:**
    - TLS 1.2 needed two round trips before sending data. TLS 1.3 needs one.
    - TLS 1.3 removed insecure cipher suites entirely (no RSA key exchange, no CBC mode)
    - 0-RTT resumption lets returning clients send encrypted data on the first packet (at the cost of replay attack risk)

- title: "Networking Security - Symmetric vs Asymmetric Encryption"
  difficulty: "medium"
  tags: ["networking", "encryption", "symmetric", "asymmetric", "TLS"]
  Front: |
    What is the difference between **symmetric** and **asymmetric** encryption?
  Back: |
    **Symmetric encryption** (AES, ChaCha20): One shared key encrypts and decrypts. Fast -- roughly 1000x faster than asymmetric. The problem: both parties need the same key, so you must securely exchange it first.

    **Asymmetric encryption** (RSA, ECC/ECDH): A public/private key pair. Encrypt with the public key, only the private key can decrypt. Also used for digital signatures and key exchange. Slow, but solves the key distribution problem -- the public key can be shared openly.

    **How they work together (TLS hybrid approach):**
    1. Asymmetric crypto (ECDHE key exchange) establishes a shared secret over an insecure channel
    2. That shared secret becomes the symmetric key (AES-256-GCM)
    3. All bulk data is encrypted with the fast symmetric cipher

    Asymmetric solves "how do we agree on a key?" Symmetric solves "how do we encrypt data fast?" Every HTTPS connection uses both.

- title: "Networking Security - CORS"
  difficulty: "medium"
  tags: ["networking", "CORS", "security", "browser", "HTTP"]
  Front: |
    What is **CORS** and why does it exist?
  Back: |
    CORS (Cross-Origin Resource Sharing) is a browser security mechanism that controls which origins can make requests to your server. An origin is the combination of scheme, host, and port (`https://app.example.com:443`).

    **Why it exists:** Browsers enforce the **same-origin policy** -- JavaScript on `app.com` cannot fetch data from `api.other.com` by default. Without this, any website could silently read your bank data using your logged-in cookies. CORS is the controlled exception to this policy.

    **How it works:**
    - Server sets `Access-Control-Allow-Origin` header to declare which origins are trusted
    - For "simple" requests (GET, POST with basic content types), the browser sends the request and checks the response header
    - For "complex" requests (PUT, DELETE, custom headers, `Content-Type: application/json`), the browser sends a **preflight OPTIONS request** first to ask for permission

    **Common mistakes:**
    - Setting `Access-Control-Allow-Origin: *` with `Access-Control-Allow-Credentials: true` -- browsers reject this combination
    - Confusing CORS with server-side security. CORS is a browser policy. curl and server-to-server calls ignore it entirely.

- title: "Networking Security - HTTPS"
  difficulty: "easy"
  tags: ["networking", "HTTPS", "TLS", "certificates"]
  Front: |
    What does **HTTPS** provide that HTTP does not?
  Back: |
    HTTPS is HTTP over TLS. It provides three guarantees that plain HTTP lacks:

    1. **Confidentiality:** Traffic is encrypted. An attacker monitoring the network sees ciphertext, not passwords or API keys.
    2. **Integrity:** Data cannot be tampered with in transit. TLS includes a message authentication code (MAC) that detects modifications.
    3. **Authentication:** The server proves its identity via a certificate signed by a trusted Certificate Authority (CA). This prevents man-in-the-middle attacks where an attacker impersonates the server.

    **What HTTPS does not provide:**
    - It does not hide *which* domain you are connecting to (the SNI extension sends the hostname in plaintext during the TLS handshake, though Encrypted Client Hello is an emerging fix)
    - It does not guarantee the server itself is trustworthy -- only that you are connected to the domain you requested
