- title: "Networking - TCP/IP Model Layers"
  difficulty: "easy"
  tags: ["networking", "TCP/IP", "OSI", "layers"]
  Front: |
    What are the **four layers of the TCP/IP model** and what does each layer do?
  Back: |
    1. **Application layer:** Where user-facing protocols live -- HTTP, DNS, SMTP, FTP. Defines how applications format and interpret data.

    2. **Transport layer:** End-to-end communication between processes. TCP provides reliable, ordered delivery with flow control. UDP provides fast, unordered delivery with no guarantees.

    3. **Internet layer:** Routes packets across networks. IP assigns addresses and handles packet forwarding. Each hop makes an independent routing decision.

    4. **Network access layer:** Handles the physical transmission of bits over a medium -- Ethernet, Wi-Fi, fiber. Deals with MAC addresses, framing, and error detection at the link level.

    The OSI model splits this into 7 layers, but TCP/IP's 4-layer model is what the internet actually runs on. In interviews, knowing TCP/IP is more practical than memorizing all 7 OSI layers.

- title: "Networking - TCP vs UDP"
  difficulty: "medium"
  tags: ["networking", "TCP", "UDP", "transport"]
  Front: |
    What is the difference between **TCP** and **UDP**? When would you choose each?
  Back: |
    **TCP (Transmission Control Protocol):**
    - Connection-oriented -- requires a handshake before data transfer
    - Guarantees delivery, ordering, and error correction via acknowledgments and retransmissions
    - Flow control and congestion control prevent overwhelming the receiver or network
    - Higher latency due to overhead

    **UDP (User Datagram Protocol):**
    - Connectionless -- sends packets immediately, no handshake
    - No delivery guarantees, no ordering, no retransmission
    - Minimal overhead -- just source port, destination port, length, checksum
    - Lower latency

    **Choose TCP for:** Anything where data integrity matters -- HTTP, file transfer, email, database connections.

    **Choose UDP for:** Anything where speed matters more than completeness -- video streaming, online gaming, DNS lookups, VoIP. A dropped video frame is better than a delayed one.

- title: "Networking - TCP Three-Way Handshake"
  difficulty: "medium"
  tags: ["networking", "TCP", "handshake", "SYN"]
  Front: |
    What happens during a **TCP three-way handshake**?
  Back: |
    The handshake establishes a TCP connection by synchronizing sequence numbers between client and server.

    1. **SYN:** Client sends a SYN packet with a random initial sequence number (e.g., seq=100).
    2. **SYN-ACK:** Server responds with its own random sequence number (e.g., seq=300) and acknowledges the client's by setting ack=101.
    3. **ACK:** Client acknowledges the server's sequence number (ack=301). Connection is established.

    **Why three steps?** Both sides must agree on initial sequence numbers so they can track which bytes have been sent and received. Two messages are not enough because the server's chosen sequence number would go unacknowledged.

    **Connection teardown** uses a four-step process (FIN, ACK, FIN, ACK) because each direction is closed independently -- one side can finish sending while the other still has data.

- title: "Networking - HTTP/1.1 vs HTTP/2 vs HTTP/3"
  difficulty: "hard"
  tags: ["networking", "HTTP", "HTTP/2", "HTTP/3", "QUIC"]
  Front: |
    What are the key differences between **HTTP/1.1**, **HTTP/2**, and **HTTP/3**?
  Back: |
    **HTTP/1.1 (1997):**
    - Text-based protocol
    - One request per TCP connection at a time (head-of-line blocking)
    - Browsers work around this by opening 6-8 parallel connections per domain
    - Chunked transfer encoding, persistent connections (keep-alive)

    **HTTP/2 (2015):**
    - Binary framing instead of text
    - **Multiplexing:** Multiple requests and responses over a single TCP connection, interleaved as frames
    - Header compression (HPACK) eliminates redundant headers
    - Server push -- server can send resources before the client requests them
    - Still suffers from **TCP-level head-of-line blocking:** a single lost packet stalls all streams

    **HTTP/3 (2022):**
    - Runs over **QUIC** (UDP-based) instead of TCP
    - Eliminates TCP head-of-line blocking -- packet loss in one stream does not affect others
    - Built-in TLS 1.3 encryption (zero extra round trips for security)
    - **Connection migration:** Survives network changes (e.g., Wi-Fi to cellular) without reconnecting

    The progression solves increasingly subtle latency problems. HTTP/2 fixed application-layer blocking. HTTP/3 fixed transport-layer blocking.
