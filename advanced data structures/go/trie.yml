# ── TRIE / PREFIX TREE ──────────────────────────────────────────────────────
- title: "Trie - Overview"
  difficulty: "medium"
  tags: ["trie", "identify"]
  Front: |
    Which tree-like structure …

    - Stores strings character-by-character down edges
    - Provides **O(k)** insert/search where k = length of string?
  Back: "Trie (Prefix Tree)"

# Insert word
- title: "Trie – Insert"
  difficulty: "medium"
  tags: ["trie", "insert"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    node := root
    for _, ch := range word {
        if node.next[ch] == nil {
            node.next[ch] = &Trie{}
        }
        node = node.next[ch]
    }
    node.isEnd = true
    ```
  Back: |
    Trie insert – O(k)

    Creates nodes on demand for each character. The `isEnd` flag distinguishes complete words from prefixes — without it, searching for "app" would falsely match inside "apple."

# Search word
- title: "Trie – Search"
  difficulty: "medium"
  tags: ["trie", "search"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    node := root
    for _, ch := range word {
        if node = node.next[ch]; node == nil { break }
    }
    found := node != nil && node.isEnd
    ```
  Back: |
    Trie search – O(k)

    Follows one edge per character. Returns true only if the traversal reaches a node marked `isEnd`. To implement prefix search (autocomplete), skip the `isEnd` check.
