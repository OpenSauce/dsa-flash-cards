# ── MONOTONIC STACK ─────────────────────────────────────────────────────────
- title: "Monotonic Stack - Overview"
  difficulty: "medium"
  tags: ["monotonic stack", "identify"]
  Front: |
    Which data structure …

    - Maintains elements in a stack such that values are **monotone**
      (only increasing or only decreasing)?
    - Is used to find **next greater / next smaller** elements in linear time?
  Back: "Monotonic Stack"

# Operation: push while maintaining decreasing order
- title: "Monotonic Stack – Push (Decreasing)"
  difficulty: "medium"
  tags: ["monotonic stack", "push"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    st := []int{}                // decreasing stack
    x  := curVal
    for len(st) > 0 && st[len(st)-1] < x {
        st = st[:len(st)-1]      // pop smaller
    }
    st = append(st, x)
    ```
  Back: |
    Monotonic stack push (maintain decreasing order) – amortised O(1)

    Each element is pushed and popped at most once across the entire input, so total work is O(n) even though individual pushes may pop multiple elements.

# Operation: next greater element query
- title: "Monotonic Stack – Next Greater Element"
  difficulty: "medium"
  tags: ["monotonic stack", "query"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    next := make([]int, len(nums))
    st   := []int{}              // store indices
    for i, v := range nums {
        for len(st) > 0 && nums[st[len(st)-1]] < v {
            idx := st[len(st)-1]
            next[idx] = v
            st = st[:len(st)-1]
        }
        st = append(st, i)
    }
    ```
  Back: |
    Next Greater Element – O(n)

    When a new value exceeds the stack top, it is the "next greater" for every popped element. Storing indices instead of values lets you write results directly into the output array.
