# ── FENWICK TREE / BINARY INDEXED TREE ──────────────────────────────────────
- title: "Fenwick Tree - Overview"
  difficulty: "medium"
  tags: ["fenwick tree", "identify"]
  Front: |
    Which data structure …

    - Stores **prefix sums** in a clever bit-indexed array
    - Supports **point updates** and **prefix queries** in **O(log n)**?
  Back: "Fenwick Tree (Binary Indexed Tree)"

# Point update
- title: "Fenwick Tree – Update"
  difficulty: "medium"
  tags: ["fenwick tree", "update"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func add(i, delta int) {
        for i <= n {
            bit[i] += delta
            i += i & -i
        }
    }
    ```
  Back: |
    Fenwick tree point update – O(log n)

    `i & -i` isolates the lowest set bit, determining which ranges include index i. Each iteration jumps to the next responsible range, touching at most log n nodes.

# Prefix sum query
- title: "Fenwick Tree – Prefix Sum"
  difficulty: "medium"
  tags: ["fenwick tree", "query"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func prefix(i int) int {
        sum := 0
        for i > 0 {
            sum += bit[i]
            i -= i & -i
        }
        return sum
    }
    ```
  Back: |
    Fenwick tree prefix sum query – O(log n)

    Accumulates partial sums by stripping the lowest set bit at each step. Simpler and faster in practice than a segment tree when you only need prefix queries (not arbitrary range queries).
