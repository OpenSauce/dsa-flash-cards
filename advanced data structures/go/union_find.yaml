# ── UNION-FIND / DISJOINT SET UNION ─────────────────────────────────────────
- title: "Union-Find - Overview"
  difficulty: "medium"
  tags: ["union find", "identify"]
  Front: |
    Which data structure …

    - Keeps track of **disjoint sets**
    - Supports **union** and **find** (with path compression) almost O(1)?
  Back: |
    **Union-Find (Disjoint Set Union)**

    A data structure that tracks elements partitioned into disjoint sets, supporting union and find in nearly O(1) amortized time with path compression and union by rank. Use for connectivity queries -- Kruskal's MST, connected components, equivalence classes. Trade-off: does not support splitting sets apart (no "un-union"), and finding all members of a specific set requires iterating every element.

# Find with path compression
- title: "Union-Find – Find (Path Compression)"
  difficulty: "medium"
  tags: ["union find", "find"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func find(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    ```
  Back: |
    Union-find with path compression (amortised α(n) ≈ O(1))

    Path compression flattens the tree by pointing every visited node directly to the root. Combined with union by rank, this gives nearly constant amortised time per operation.

# Union by rank
- title: "Union-Find – Union (By Rank)"
  difficulty: "medium"
  tags: ["union find", "union"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func union(a, b int) {
        ra, rb := find(a), find(b)
        if ra == rb { return }
        if rank[ra] < rank[rb] {
            parent[ra] = rb
        } else if rank[ra] > rank[rb] {
            parent[rb] = ra
        } else {
            parent[rb] = ra
            rank[ra]++
        }
    }
    ```
  Back: |
    Union by rank (amortised α(n) ≈ O(1))

    Attaching the shorter tree under the taller one keeps height logarithmic. The early return when `ra == rb` prevents creating cycles. Essential for Kruskal's MST and connected-component queries.
