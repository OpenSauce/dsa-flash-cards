# ── SKIP LIST ───────────────────────────────────────────────────────────────
- title: "Skip List - Overview"
  difficulty: "hard"
  tags: ["skip list", "identify"]
  Front: |
    Which probabilistic data structure …

    - Layers multiple forward pointers over a linked list
    - Achieves **O(log n)** expected search/insert/delete?
  Back: |
    **Skip List**

    A probabilistic data structure that layers multiple levels of forward pointers over a sorted linked list, achieving O(log n) expected search, insert, and delete. Use as a simpler alternative to balanced BSTs -- easier to implement and naturally supports concurrent access (e.g., Redis sorted sets, Java ConcurrentSkipListMap). Trade-off: probabilistic guarantees only (no worst-case bound) and higher memory usage due to multi-level pointers.

# Search
- title: "Skip List – Search"
  difficulty: "hard"
  tags: ["skip list", "search"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    x := head
    for level := maxLevel-1; level >= 0; level-- {
        for x.next[level] != nil && x.next[level].key < key {
            x = x.next[level]
        }
    }
    x = x.next[0]
    ```
  Back: |
    Skip list search (expected O(log n))

    Starts at the highest level and drops down when the next pointer overshoots. Each level roughly halves the nodes traversed, giving logarithmic expected time similar to a balanced BST.

# Insert (outline)
- title: "Skip List – Insert"
  difficulty: "hard"
  tags: ["skip list", "insert"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    lvl  := randomLevel()
    node := newNode(key, lvl)

    for i := 0; i < lvl; i++ {          // splice into each level
        node.next[i]   = update[i].next[i]
        update[i].next[i] = node
    }
    ```
  Back: |
    Skip list insert with random level (expected O(log n))

    The random level (usually geometric with p=0.5) probabilistically balances the structure without rotations. The `update` array records the last node at each level before the insertion point.
