# ── SEGMENT TREE ────────────────────────────────────────────────────────────
- title: "Segment Tree - Overview"
  difficulty: "hard"
  tags: ["segment tree", "identify"]
  Front: |
    Which data structure …

    - Recursively partitions an array into **intervals**
    - Supports **range queries** and **point updates** in **O(log n)**?
  Back: "Segment Tree"

# Build tree (bottom‑up)
- title: "Segment Tree – Build"
  difficulty: "medium"
  tags: ["segment tree", "build"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    size := 1
    for size < n { size <<= 1 }
    seg := make([]int, 2*size)
    for i := 0; i < n; i++ {
        seg[size+i] = arr[i]
    }
    for i := size-1; i > 0; i-- {
        seg[i] = seg[2*i] + seg[2*i+1]
    }
    ```
  Back: |
    Segment tree build – O(n)

    Leaves hold the original values; each internal node stores the sum of its two children. Building bottom‑up avoids recursion and is cache‑friendlier than top‑down construction.

# Range sum query
- title: "Segment Tree – Range Query"
  difficulty: "hard"
  tags: ["segment tree", "query"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func query(l, r int) int {      // inclusive [l,r)
        l += size; r += size
        res := 0
        for l < r {
            if l&1 == 1 { res += seg[l]; l++ }
            if r&1 == 1 { r--; res += seg[r] }
            l >>= 1; r >>= 1
        }
        return res
    }
    ```
  Back: |
    Segment tree range query – O(log n)

    Walks up from the leaves, collecting partial sums from nodes that fall fully inside the query range. At most two nodes per level are visited, giving O(log n) total.

# Point update
- title: "Segment Tree – Point Update"
  difficulty: "hard"
  tags: ["segment tree", "update"]
  Front: |
    What operation does this implement, and what is its time complexity?

    ```go
    func update(pos, val int) {
        i := size + pos
        seg[i] = val
        for i >>= 1; i > 0; i >>= 1 {
            seg[i] = seg[2*i] + seg[2*i+1]
        }
    }
    ```
  Back: |
    Segment tree point update – O(log n)

    Updates the leaf, then propagates the change upward by recomputing each ancestor. Only the nodes on the root‑to‑leaf path are touched.
