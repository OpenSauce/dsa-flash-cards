# ── PREFIX SUM ─────────────────────────────────────────────────────────────
- title: "Prefix Sum - Overview"
  difficulty: "easy"
  tags: ["prefix sum", "identify"]
  Front: |
    Which pre-processing method …

    - Builds an array of **cumulative totals**
    - Answers **range-sum queries** in **O(1)** after **O(n)** build?
  Back: |
    **Prefix Sum**

    A preprocessing technique that builds an array of cumulative totals in O(n), then answers any range-sum query in O(1). Use when you have many range-sum queries on static data. Trade-off: requires O(n) extra space and does not handle point updates efficiently -- use a Fenwick tree or segment tree when the underlying data changes.

- title: "Prefix Sum – Build & Range Query"
  difficulty: "easy"
  tags: ["prefix sum", "implementation"]
  Front: |
    What algorithm technique is this? What problem does it solve?

    ```go
    pre := make([]int, len(a)+1)
    for i, v := range a { pre[i+1] = pre[i] + v }
    rangeSum := func(l, r int) int { // [l,r)
        return pre[r] - pre[l]
    }
    ```
  Back: |
    Prefix sum – build O(n), query O(1)

    Trades O(n) space for O(1) range-sum queries via the identity `sum(l,r) = pre[r] − pre[l]`. The extra element `pre[0] = 0` avoids special-casing the range starting at index 0.
