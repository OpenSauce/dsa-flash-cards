# ── DEPTH-FIRST SEARCH ─────────────────────────────────────────────────────
- title: "Depth-First Search - Overview"
  difficulty: "easy"
  tags: ["dfs", "identify", "graph traversal"]
  Front: |
    Which graph traversal …

    - Explores as far as possible along each branch before backtracking
    - Uses **recursion or an explicit stack**
    - Runs in **O(V+E)** time?
  Back: "Depth-First Search (DFS)"

- title: "DFS – Recursive"
  difficulty: "easy"
  tags: ["dfs", "implementation"]
  Front: |
    What graph traversal algorithm is this? What is its time and space complexity?

    ```go
    func dfs(v int) {
        vis[v] = true
        for _, nb := range g[v] {
            if !vis[nb] { dfs(nb) }
        }
    }
    ```
  Back: |
    DFS traversal (O(V+E))

    Recursion uses the call stack implicitly — stack depth equals the longest path, so very deep graphs can overflow. Switch to an explicit stack for graphs with depth > ~10k nodes.
