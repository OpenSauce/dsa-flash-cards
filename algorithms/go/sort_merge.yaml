# ── MERGE SORT ─────────────────────────────────────────────────────────────
- title: "Merge Sort - Overview"
  difficulty: "medium"
  tags: ["merge sort", "identify", "sorting", "divide and conquer"]
  Front: |
    Which sorting algorithm …

    - Uses **divide-and-conquer** to split, sort, and merge halves
    - Guarantees **O(n log n)** time
    - Requires **O(n)** extra space?
  Back: |
    **Merge Sort**

    A divide-and-conquer sorting algorithm that splits the array in half, recursively sorts each half, and merges the results in O(n log n) guaranteed time. Use when you need a stable sort or a worst-case O(n log n) guarantee. Trade-off: requires O(n) extra space for the merge step, unlike in-place alternatives like quicksort.

- title: "Merge Sort – Recursive"
  difficulty: "medium"
  tags: ["merge sort", "implementation"]
  Front: |
    What sorting algorithm is this? What is its time and space complexity?

    ```go
    func mergeSort(a []int) []int {
        if len(a) <= 1 { return a }
        mid := len(a) / 2
        left  := mergeSort(a[:mid])
        right := mergeSort(a[mid:])
        return merge(left, right)
    }
    ```
  Back: |
    Merge Sort (O(n log n) time, O(n) space)

    Guaranteed O(n log n) regardless of input — no quadratic worst case. The O(n) extra space is the main trade-off vs. quicksort. Stable and naturally parallelisable since the two halves are independent.
