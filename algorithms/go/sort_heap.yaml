# ── HEAP SORT ──────────────────────────────────────────────────────────────
- title: "Heap Sort - Overview"
  difficulty: "medium"
  tags: ["heap sort", "identify", "sorting"]
  Front: |
    Which sorting algorithm …

    - Builds a **binary heap** then repeatedly extracts max/min
    - Runs in **O(n log n)** time
    - Sorts **in-place** with `O(1)` extra memory?
  Back: |
    **Heap Sort**

    A sorting algorithm that builds a binary heap and repeatedly extracts the max, running in O(n log n) guaranteed time with O(1) extra space. Use when you need both a worst-case time guarantee and in-place sorting. Trade-off: poor cache locality and not stable, making it slower in practice than quicksort despite the better worst-case guarantee.

- title: "Heap Sort – Implementation (Max-Heap)"
  difficulty: "medium"
  tags: ["heap sort", "implementation"]
  Front: |
    What sorting algorithm is this? What is its time and space complexity?

    ```go
    heapify(a)                // O(n)
    for end := n-1; end > 0; end-- {
        a[0], a[end] = a[end], a[0]
        siftDown(a, 0, end)   // O(log n)
    }
    ```
  Back: |
    Heap Sort (O(n log n) time, O(1) space)

    Guaranteed O(n log n) with no extra memory — combines the best of merge sort's time guarantee and quicksort's space efficiency. Not stable and poor cache locality make it slower in practice than quicksort.
