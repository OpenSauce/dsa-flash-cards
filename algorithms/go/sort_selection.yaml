# ── SELECTION SORT ─────────────────────────────────────────────────────────
- title: "Selection Sort - Overview"
  difficulty: "easy"
  tags: ["selection sort", "identify", "sorting"]
  Front: |
    Which sorting algorithm …

    - Repeatedly selects the **minimum** remaining element
    - Swaps it into the correct position
    - Always runs in **O(n²)** time?
  Back: |
    **Selection Sort**

    A sorting algorithm that repeatedly finds the minimum remaining element and swaps it into position, always running in O(n^2) time. Use when the number of writes matters -- it performs at most n swaps, which is useful when writing is expensive (e.g., flash memory). Trade-off: no best-case shortcut like insertion sort; always does n(n-1)/2 comparisons regardless of input order.

- title: "Selection Sort – Implementation"
  difficulty: "easy"
  tags: ["selection sort", "implementation"]
  Front: |
    What sorting algorithm is this? What is its time and space complexity?

    ```go
    for i := 0; i < n-1; i++ {
        min := i
        for j := i + 1; j < n; j++ {
            if a[j] < a[min] { min = j }
        }
        a[i], a[min] = a[min], a[i]
    }
    ```
  Back: |
    Selection Sort (O(n²) time, O(1) space)

    Always performs n(n−1)/2 comparisons regardless of input order — no best-case shortcut. Useful when writes are expensive since it does at most n swaps, but insertion sort is generally preferred.
