# ── QUICK SORT ─────────────────────────────────────────────────────────────
- title: "Quick Sort - Overview"
  difficulty: "medium"
  tags: ["quick sort", "identify", "sorting", "divide and conquer"]
  Front: |
    Which sorting algorithm …

    - Partitions around a **pivot**
    - Has **O(n log n)** average but **O(n²)** worst-case
    - Often fastest in practice with good pivot choice?
  Back: |
    **Quick Sort**

    A divide-and-conquer sorting algorithm that partitions around a pivot, achieving O(n log n) average time and sorting in-place. Often the fastest general-purpose sort in practice due to cache locality and low constant factors. Trade-off: O(n^2) worst case when pivots are poorly chosen (e.g., sorted input with fixed pivot) -- mitigate with randomized or median-of-three pivot selection.

- title: "Quick Sort – Lomuto Partition"
  difficulty: "medium"
  tags: ["quick sort", "implementation"]
  Front: |
    What sorting algorithm is this? What is its time and space complexity?

    ```go
    func quickSort(a []int, lo, hi int) {
        if lo < hi {
            p := partition(a, lo, hi)
            quickSort(a, lo, p-1)
            quickSort(a, p+1, hi)
        }
    }
    ```
  Back: |
    Quick Sort (avg O(n log n), worst O(n²), O(log n) stack space)

    Worst case hits when the pivot is always the min or max (e.g., sorted input with last-element pivot). Mitigate with median-of-three or random pivot selection. In-place and cache-friendly, making it faster than merge sort in practice.
