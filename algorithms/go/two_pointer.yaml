# ── TWO‑POINTER TECHNIQUE ──────────────────────────────────────────────────
- title: "Two‑Pointer Technique - Overview"
  difficulty: "easy"
  tags: ["two pointer", "identify", "array"]
  Front: |
    Which array/string technique …

    - Uses **two indices** that move toward each other or at different speeds
    - Solves many problems in **O(n)** without extra space (e.g., pair sum, palindrome)?
  Back: "Two‑Pointer Technique"

- title: "Two‑Pointer – Pair Sum (Sorted)"
  difficulty: "easy"
  tags: ["two pointer", "implementation"]
  Front: |
    What algorithm technique is this? What problem does it solve?

    ```go
    l, r := 0, len(a)-1
    for l < r {
        s := a[l] + a[r]
        if s == target { return true }
        if s < target { l++ } else { r-- }
    }
    ```
  Back: |
    Two‑pointer pair sum on sorted array – O(n)

    The sorted invariant lets you decide which pointer to move: too small → advance left, too large → advance right. This eliminates the need for a hash set and uses O(1) extra space.
