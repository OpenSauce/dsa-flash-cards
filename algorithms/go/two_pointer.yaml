# ── TWO-POINTER TECHNIQUE ──────────────────────────────────────────────────
- title: "Two-Pointer Technique - Overview"
  difficulty: "easy"
  tags: ["two pointer", "identify", "array"]
  Front: |
    Which array/string technique …

    - Uses **two indices** that move toward each other or at different speeds
    - Solves many problems in **O(n)** without extra space (e.g., pair sum, palindrome)?
  Back: |
    **Two-Pointer Technique**

    A technique using two indices that move through sorted or structured data, solving problems like pair sum and palindrome checking in O(n) with O(1) space. Use on sorted arrays or linked lists where shrinking a search window converges on the answer. Trade-off: requires sorted input or a specific traversal order -- unsorted data typically needs a hash set approach instead.

- title: "Two-Pointer – Pair Sum (Sorted)"
  difficulty: "easy"
  tags: ["two pointer", "implementation"]
  Front: |
    What algorithm technique is this? What problem does it solve?

    ```go
    l, r := 0, len(a)-1
    for l < r {
        s := a[l] + a[r]
        if s == target { return true }
        if s < target { l++ } else { r-- }
    }
    ```
  Back: |
    Two-pointer pair sum on sorted array – O(n)

    The sorted invariant lets you decide which pointer to move: too small → advance left, too large → advance right. This eliminates the need for a hash set and uses O(1) extra space.
