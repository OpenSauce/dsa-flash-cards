# ── INSERTION SORT ─────────────────────────────────────────────────────────
- title: "Insertion Sort - Overview"
  difficulty: "easy"
  tags: ["insertion sort", "identify", "sorting"]
  Front: |
    Which sorting algorithm …

    - Builds the final array one item at a time
    - Shifts larger elements right to insert the current key
    - Runs in **O(n²)** worst-case but **O(n)** on nearly-sorted data?
  Back: |
    **Insertion Sort**

    A sorting algorithm that builds the sorted array one element at a time by shifting larger elements right, running in O(n^2) worst case but O(n) on nearly-sorted data. Use for small arrays or as a finishing pass inside hybrid sorts like Timsort and introsort. Trade-off: quadratic on reverse-sorted input, but its low overhead and stability make it the best choice for small n.

- title: "Insertion Sort – Implementation"
  difficulty: "easy"
  tags: ["insertion sort", "implementation"]
  Front: |
    What sorting algorithm is this? What is its time and space complexity?

    ```go
    for i := 1; i < n; i++ {
        key := a[i]
        j   := i - 1
        for j >= 0 && a[j] > key {
            a[j+1] = a[j]
            j--
        }
        a[j+1] = key
    }
    ```
  Back: |
    Insertion Sort (O(n²) worst, O(n) best, O(1) space)

    Efficient for small or nearly-sorted arrays — many real-world sorts (like Go's `sort.Slice`) switch to insertion sort below ~12 elements. Stable: equal elements keep their original order.
